Una api es un contrato (definiciones, especificaciones, entradas, salidas, protocolos) que se define para que 
dos o mas componentes tecnologicos interactuen entre si o se intregren entre si, o se comuniquen entre si, 
Una API encapsula toda su lógica que implementa para cumplir con estos contratos, define el qué no el cómo

Por su estilo arquitectónico existen las siguiente categorías:
- RESTful -> implementación del estilo arquitectónico (principios de diseño) REST (Representationl State Transfer), estándar JSON 
- SOAP -> Basadas en XML, esquemas rígidos
- GRPC -> API de comunicación basado en http/2, eficiente para el backend interno
- Asincronas -> Se manejan con mensajerías o colas, no necesariamente son web, basadas en eventos, desacoplamiento entre los componentes
- GRApHQL -> Es un lenguaje de consulta para APIs donde el cliente define lo que necesita.

Princpios Calve RESTful
1. Recursos: Todo objetos con el trabajamos es un recurso, Como una Entidad en JPA
2. Cliente Servidor: 
3. Sin Estado: Stateless, no guarda el estado para la siguiente pregunta, cada petición es independiente
4. Uso correcto de http: Métodos http 
GET (consultas)
POST (insertar)
PUT (actualizar)
PATCH (actualizar parcialmente un recuso)
DELETE (eliminar)
5. Representaciones: cuando utilizo una capacidad de mi api para crear un recurso, se debe enviar el objeto, es una representacion del objeto, no se tabaja con el objeto real
6. Códigos de Estado: cuando se consume una api se obtiene una respuesta, 
7. Cacheable: la api puede manejar información volatil, osea información guardada en el caché
8. Por capas: Capas correctamente estructurada --- Acceso a Datos, Lógica de Negocios, Controlador.

Micro Profile: es un conjunto de especificaciones para la construcción de APIS Web basadas en java y orientadas para microservicios.
Quarkus,(Marco Integral de Java) como implementación de microprofile -> consume menos cpu y memoria por que compila y optimiza al SO con lenguaje nativo.


----------------------
ARQUITECTURA DE MICROSERVICIOS

DOMAIN DRIVEN DESING (DDD): Metodología de Software - El software debe dividirse por dominios funcionales
- Domain: Mapeo de entidades (representacion de una tabla en una base de datos)
- Infraestructura: Acceso a los datos (conexión)
- Aplication: Logica de Negocio de la aplicacion
- Interfaces: Reside el controlador y acceso a recursos (endPoints - paths)

Cada capa debe ser representada como paquetes

-------------------------------------------------------------------------------

Modelo de Madurez de Richardson: mejorar la calidad en la construccion de APIs
    Modelo que permite clasificar la madurez de una API REST y existen 4 niveles:
        -Nivel 0: debe trabajar con el modelo HTTP/HTTPS 
        -Nivel 1: maneja todo como un recurso (Recurso -> URI) y las URIs deben ser autodescriptivas
        Nomenclatura: URL = http://localhost:8080/(nombre relacionado) matricula/api/v1.0/(nombre del recurso en plural) estudiantes
        
        versiones maximo 2 digitos, es lo mas optimo
        1.1.2
        cambios mayores-cambios minimos-errores
        
        Verbos: el verbo es autodescriptivo, pude existir un mismo endpoint pero con diferente verbo
        .../estudiantes         GET
        .../estudiantes/{id}    GET
        .../estudiantes/{id}    DELETE 
        .../estudiantes/{id}    PATCH   Body  
        .../estudiantes         POST    Body (para 1 o varios objetos)
        .../estudiantes/{id}    PUT     Body

        
        - Nivel 2, Se compone por 3 elementos: 
            1. Uso correcto de verbos o metodos http (Podemos usar POST para hacer consultar, pero es incorrecto) 
            2. Uso correcto de codigos de estado - Los codigos: son respuestas al realizar un petición http dependen del metodo de peticion utilizado
            3. Tipo o formato correcto y explícito del contenidto del body que viaja en el request o response, el formato debe ser definido explicitamente tanto en el request como en el response. (consumes y produces)

            - Manejo de códigos de estado: 5 Grupos 
                1. Respuestas informativas: rango destinado 100 - 199 (100-1xx): No necesariamente hubo un error o exito, me da informacion relevante "El sistema estara disponible el lunes...."
                2. Respuestas satisfactorias: rango destinado (200-2xx): Todo fue bien en el consumo de la api "Transaccion exitosa"
                3. Mensajes de redirección: 300-3xx: Menos comun, cuando hay un cambio en el endpoint de la api, proceso de transicion en versiones, no siempre se da de baja a la version anterior
                4. Mensajes de error en el cliente: 400-4xx: El navegador es el cliente generalmente, puede ser postman
                5. Errores de servidor: 500-5xx: El que provee el servicio, puede ser Quarkus
                
                Existen codigos reservados y codigos que podemos personalizar
                
                Codigos estandar:
                    1. 100.- destinado para informar que todo esta correcto pero aun se continua procesando la solicitud
                    2. 102.- indica que el servidor a resivido la solicitud, que todavia esta procesando pero aun no hay una respuesta definida
                
                    3. 200.- el request ha tenido éxito, que todo ha salido bien el la peticion, suele englobar todos las peticiones de acuerdo a todos los verbos
                    4. 201.- indica que se ha creado un nuevo recurso de manera exitosa, es decir con el verbo POST
                    5. 204.- la peticion fue procesada correctamente pero no hay respuesta (sin return)

                    6. 400.- BAD REQUEST, indica que hubo un error de sintaxis o está mal estructurada la peticion
                    7. 401.- UNAUTHORIZED, error en la autenticacion, el usuario no está identificado correctamente
                    8. 403.- FORBIDDEN, no está autorizado para consumir la API, aunque esté autenticado
                    9. 404.- NOT FOUND, se hizo una petición a algo que no existe, recurso o URL incorrecta
                    10. 405.- METHOD NOT ALLOWED, método o verbo HTTP incorrecto para el recurso solicitado
                    11. 408.- REQUEST TIMEOUT, la petición se desconectó porque excedió el tiempo límite
                    12. 415.- UNSUPPORTED MEDIA TYPE, el formato del contenido del body es incorrecto o no soportado

                    13. 500.- Internal Server Error, cualquier error de la API (en el codigo fuente)
                    14. 503.- Servicio no disponible, el servidor no está listo para recibir la petición todavía
        
            Richardson.- Use los codigos no reservados correctamente: https://developer.mozilla.org/es/docs/Web/HTTP/Reference/Status
-------------------------------------------------------------------------------------------------------------

Siempre poner el produces, consumes o ambos explicitamente
Se puede poner a nivel de clase, pero es mejor poner a nivel del metodo

        - Nivel 3: HATEOAS (Hypermedia As The Engine Of Application State)
            - Es ineficiente traer demasiada información en una sola petición, (informacion del hijo de un estudiante)
            - Consiste en que la API devuelva en la respuesta enlaces (links) a otros recursos (endpoints) relacionados con el recurso solicitado
                se debe incluir en el resource padre
            - No debemos exponer directamente las entidades en el resource, debemos usar otro objeto


------------------------------------------------------------------------------------------------------------------
Autenticacion y Autorizacion
- Autenticacion: proceso de verificar la identidad de un usuario o sistema (quien eres), probar que soy quien digo ser 
    Mecanismo 1. mediante credenciales que yo se (usuario y contraseña)
    Mecanismo 2. algo que yo tengo (token, otp, certificado digital)
    Mecanismo 3. algo que yo soy (biometria: huella digital, reconocimiento facial)

- Autorizacion: proceso de verificar si un usuario o sistema tiene permisos para acceder a un recurso o realizar una acción específica (que puedes hacer)
    A que recursos puedo acceder y que acciones puedo realizar en esos recursos
    Se da despues de la autenticacion
    Llave privada y llave publica, a partir de la llave privada se genera un certificado digital (llave publica)
    - OAuth2.0: protocolo de autorizacion basado en una autenticaion previa, autorization server (API proveedor de autorizacion para poder consumir otras APIs)

    El cliente pide autorizacion al authorization server, si es correcto, el authorization server le da un token de acceso (access token) al cliente
    El cliente usa el access token (basado en json: JWT - JSON Web Token) para consumir la API protegida (resource server)

    Openssl es una herramienta para generar certificados digitales y llaves criptograficas
    Comando 1: openssl genpkey -algorithm RSA -out privateKey.pem -pkeyopt rsa_keygen_bits:2048
    Comando 2: openssl rsa -pubout -in privateKey.pem -out publicKey.pem

- Authorization de páginas web - Proteger las rutas
    En Vue conocidos como guards, guardianes de rutas
    Usa la funcion next() para redirigir a otra pagina, desde To ha From

    router.beforeEach es un método en Vue Router que se utiliza para registrar un guardia global que se ejecuta antes de cada navegación. Este permite realizar verificaciones o lógica personalizada (como autenticación o permisos) antes de permitir que el usuario acceda a una ruta específica.

        to: La ruta a la que el usuario intenta navegar.
        from: La ruta desde la que el usuario está navegando.
        next: Una función que se llama para continuar la navegación o redirigir a otra ruta.